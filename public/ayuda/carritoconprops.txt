
Mejoras Clave en Busquedas

1. Manejo del Término de Búsqueda (Robustez)

  Código Original	Código Mejorado	Beneficio
    const txtBuscar = location.state;	        // original
    const txtBuscar = location.state?.trim()  // mejorado	
  
    const URI=API+txtBuscar;	                                            // original
    const URI = txtBuscar ? API + encodeURIComponent(txtBuscar) : null;	  // mejorado
  
  ✅ Seguridad de URL: Utiliza encodeURIComponent() para hacer que la URL sea válida, manejando espacios y caracteres especiales.

2. Rendimiento y Advertencias de React (Eficiencia)

  Código Original	Código Mejorado	Beneficio
    const getDatos = async () => {...}	
    const getDatos = useCallback(async () => {...}, [URI]);	
    ✅ Estabilidad de la Función: 
        El uso de useCallback "memoriza" la función getDatos. 
        Esto evita que la función se recree en cada renderizado, lo que a su vez elimina la advertencia de dependencia de useEffect y mejora el rendimiento.

    useEffect(() => { getDatos(); }, [txtBuscar]);	
    useEffect(() => { /* lógica de verificación */ }, [txtBuscar, getDatos]);	
    ✅ Uso Correcto de Dependencias: 
        Al usar useCallback, se sigue la regla de React de incluir a getDatos en el array de dependencias de useEffect sin causar bucles de renderizado.

3. Experiencia de Usuario y Lógica (UX y Robustez)

  Código Original	Código Mejorado	Beneficio
    Sin validación para txtBuscar vacío.	
    Incluye if (!URI) { ... return; } en getDatos.	
    ✅ Control de Flujo: 
      Detiene la llamada a fetch si no hay término de búsqueda, evitando solicitudes innecesarias o con errores.

      El setLoading(false) solo está en el try y en el catch.	
      El setLoading(false) está en el bloque finally.	
    ✅ Manejo de Carga: 
        Garantiza que el estado de carga (loading) siempre se desactive, 
        incluso si hay un error desconocido o no manejado dentro del try/catch.

      













🛒 Etapa 3: Carrito de Compras – Versión 1 (Gestión con Props)
🎯 Objetivo
Implementar un carrito de compras funcional que permita a los usuarios:

Agregar productos desde la tienda o tarjetas.
Ver el contenido del carrito en un panel lateral (Offcanvas de Bootstrap).
Modificar cantidades, eliminar productos y vaciar el carrito.
Persistir el carrito entre recargas de la página usando localStorage.
Esta versión no usa Context API, sino que gestiona el estado del carrito en el componente raíz (App.jsx) y lo pasa como prop a los componentes que lo necesitan.


Arquitectura del Estado
Componente                      Responsabilidad
----------------------------------------------------------------------------------------------------------
App.jsx                         - Contiene el estado del carrito (useState).
                                - Define funciones para gestionarlo (agregar,eliminar, etc.).
                                - Persiste el carrito en localStorage       
                                - Pasa el carrito y sus funciones como props.

Header.jsx                      - Muestra un botón con el número de productos.
                                - Renderiza el CarritoOffcanvas
                                - Recibe el carrito y las funciones como props.

Cardprod.jsx                    - Muestra un botón “+ Agregar”.
                                - Llama a agregarAlCarrito al hacer clic.
                                - Recibe la función como prop.

Tienda.jsx                      - Renderiza la lista de productos.
                                - Pasa agregarAlCarrito a cada Cardprod

CarritoOffcanvas.jsx            - Muestra los productos del carrito.    
                                - Permite modificar cantidades, eliminar y vaciar.
                                - Usa las funciones recibidas por props (¡no tiene estado propio!).



💾 Persistencia con localStorage
Para que el carrito no se pierda al recargar la página, se utiliza localStorage:

✅ Inicialización segura del estado:

en la zona de importacion 
    const getInitialCart = () => {
    try {
        const saved = localStorage.getItem("cart");
        return saved ? JSON.parse(saved) : [];
    } catch (e) {
        console.error("Error al cargar el carrito");
        return [];
    }
    };

en la zona de la logica 
    const [carrito, setCarrito] = useState(getInitialCart);

    ✅ Guardado automático:

    useEffect(() => {
        localStorage.setItem("cart", JSON.stringify(carrito));
    }, [carrito]); // al cambiar el carrito actualiza el cart

    ✨ Ventaja: El carrito sobrevive a recargas, cierres del navegador y navegación. 



📦 Funcionalidades implementadas – Etapa 3: Carrito 1 (con props)
✅ Agregar producto: si ya existe en el carrito, incrementa su cantidad.
✅ Eliminar producto: elimina un ítem específico del carrito.
✅ Actualizar cantidad: botones + y – para modificar unidades directamente en el Offcanvas.
✅ Vaciar carrito: con confirmación previa para evitar acciones accidentales.
✅ Enviar pedido: envía el carrito simulado a https://dummyjson.com/carts/add con confirmación de compra.
✅ Mostrar totales:
    Total de productos únicos.
    Cantidad total de ítems.
    Monto total a pagar (suma de precio × cantidad).
✅ Indicador visual en tarjetas: badge amarillo con la cantidad si el producto está en el carrito.
✅ Contador en el botón del carrito: solo visible si hay productos (Carrito (3)).
✅ Interfaz con Offcanvas de Bootstrap: panel lateral deslizable con resumen del carrito.
✅ Persistencia con localStorage: el carrito se mantiene entre recargas y sesiones.



⚠️ Limitaciones de esta versión (para reflexión)
    Prop drilling: el carrito y sus funciones se pasan por muchos niveles de componentes.
    Difícil de escalar: si más componentes necesitan el carrito, hay que seguir pasando props.
    Acoplamiento: muchos componentes dependen directamente de App.jsx.
    💡 Esto prepara el terreno para la próxima etapa: usar Context API como solución a estos problemas. 

📌 Conclusión
Esta versión del carrito:

Es funcional, robusta y didáctica.
Refuerza los fundamentos de React (estado, props, efectos).
Introduce buenas prácticas de persistencia.
Sirve como base para entender por qué necesitamos Context API en aplicaciones más grandes.
