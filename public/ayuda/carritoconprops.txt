
Mejoras Clave en Busquedas

1. Manejo del TÃ©rmino de BÃºsqueda (Robustez)

  CÃ³digo Original	CÃ³digo Mejorado	Beneficio
    const txtBuscar = location.state;	        // original
    const txtBuscar = location.state?.trim()  // mejorado	
  
    const URI=API+txtBuscar;	                                            // original
    const URI = txtBuscar ? API + encodeURIComponent(txtBuscar) : null;	  // mejorado
  
  âœ… Seguridad de URL: Utiliza encodeURIComponent() para hacer que la URL sea vÃ¡lida, manejando espacios y caracteres especiales.

2. Rendimiento y Advertencias de React (Eficiencia)

  CÃ³digo Original	CÃ³digo Mejorado	Beneficio
    const getDatos = async () => {...}	
    const getDatos = useCallback(async () => {...}, [URI]);	
    âœ… Estabilidad de la FunciÃ³n: 
        El uso de useCallback "memoriza" la funciÃ³n getDatos. 
        Esto evita que la funciÃ³n se recree en cada renderizado, lo que a su vez elimina la advertencia de dependencia de useEffect y mejora el rendimiento.

    useEffect(() => { getDatos(); }, [txtBuscar]);	
    useEffect(() => { /* lÃ³gica de verificaciÃ³n */ }, [txtBuscar, getDatos]);	
    âœ… Uso Correcto de Dependencias: 
        Al usar useCallback, se sigue la regla de React de incluir a getDatos en el array de dependencias de useEffect sin causar bucles de renderizado.

3. Experiencia de Usuario y LÃ³gica (UX y Robustez)

  CÃ³digo Original	CÃ³digo Mejorado	Beneficio
    Sin validaciÃ³n para txtBuscar vacÃ­o.	
    Incluye if (!URI) { ... return; } en getDatos.	
    âœ… Control de Flujo: 
      Detiene la llamada a fetch si no hay tÃ©rmino de bÃºsqueda, evitando solicitudes innecesarias o con errores.

      El setLoading(false) solo estÃ¡ en el try y en el catch.	
      El setLoading(false) estÃ¡ en el bloque finally.	
    âœ… Manejo de Carga: 
        Garantiza que el estado de carga (loading) siempre se desactive, 
        incluso si hay un error desconocido o no manejado dentro del try/catch.

      








======================================================================================================================================================================
ğŸ›’ Etapa 3: Carrito de Compras â€“ VersiÃ³n 1 (GestiÃ³n con Props)
======================================================================================================================================================================

ğŸ¯ Objetivo
Implementar un carrito de compras funcional que permita a los usuarios:

Agregar productos desde la tienda o tarjetas.
Ver el contenido del carrito en un panel lateral (Offcanvas de Bootstrap).
Modificar cantidades, eliminar productos y vaciar el carrito.
Persistir el carrito entre recargas de la pÃ¡gina usando localStorage.
Esta versiÃ³n no usa Context API, sino que gestiona el estado del carrito en el componente raÃ­z (App.jsx) y lo pasa como prop a los componentes que lo necesitan.


Arquitectura del Estado
Componente                      Responsabilidad
----------------------------------------------------------------------------------------------------------
App.jsx                         - Contiene el estado del carrito (useState).
                                - Define funciones para gestionarlo (agregar,eliminar, etc.).
                                - Persiste el carrito en localStorage       
                                - Pasa el carrito y sus funciones como props.

Header.jsx                      - Muestra un botÃ³n con el nÃºmero de productos.
                                - Renderiza el CarritoOffcanvas
                                - Recibe el carrito y las funciones como props.

Cardprod.jsx                    - Muestra un botÃ³n â€œ+ Agregarâ€.
                                - Llama a agregarAlCarrito al hacer clic.
                                - Recibe la funciÃ³n como prop.

Tienda.jsx                      - Renderiza la lista de productos.
                                - Pasa agregarAlCarrito a cada Cardprod

CarritoOffcanvas.jsx            - Muestra los productos del carrito.    
                                - Permite modificar cantidades, eliminar y vaciar.
                                - Usa las funciones recibidas por props (Â¡no tiene estado propio!).



ğŸ’¾ Persistencia con localStorage
Para que el carrito no se pierda al recargar la pÃ¡gina, se utiliza localStorage:

âœ… InicializaciÃ³n segura del estado:

en la zona de importacion 
    const getInitialCart = () => {
    try {
        const saved = localStorage.getItem("cart");
        return saved ? JSON.parse(saved) : [];
    } catch (e) {
        console.error("Error al cargar el carrito");
        return [];
    }
    };

en la zona de la logica 
    const [carrito, setCarrito] = useState(getInitialCart);

    âœ… Guardado automÃ¡tico:

    useEffect(() => {
        localStorage.setItem("cart", JSON.stringify(carrito));
    }, [carrito]); // al cambiar el carrito actualiza el cart

    âœ¨ Ventaja: El carrito sobrevive a recargas, cierres del navegador y navegaciÃ³n. 



ğŸ“¦ Funcionalidades implementadas â€“ Etapa 3: Carrito 1 (con props)
âœ… Agregar producto: si ya existe en el carrito, incrementa su cantidad.
âœ… Eliminar producto: elimina un Ã­tem especÃ­fico del carrito.
âœ… Actualizar cantidad: botones + y â€“ para modificar unidades directamente en el Offcanvas.
âœ… Vaciar carrito: con confirmaciÃ³n previa para evitar acciones accidentales.
âœ… Enviar pedido: envÃ­a el carrito simulado a https://dummyjson.com/carts/add con confirmaciÃ³n de compra.
âœ… Mostrar totales:
    Total de productos Ãºnicos.
    Cantidad total de Ã­tems.
    Monto total a pagar (suma de precio Ã— cantidad).
âœ… Indicador visual en tarjetas: badge amarillo con la cantidad si el producto estÃ¡ en el carrito.
âœ… Contador en el botÃ³n del carrito: solo visible si hay productos (Carrito (3)).
âœ… Interfaz con Offcanvas de Bootstrap: panel lateral deslizable con resumen del carrito.
âœ… Persistencia con localStorage: el carrito se mantiene entre recargas y sesiones.



âš ï¸ Limitaciones de esta versiÃ³n (para reflexiÃ³n)
    Prop drilling: el carrito y sus funciones se pasan por muchos niveles de componentes.
    DifÃ­cil de escalar: si mÃ¡s componentes necesitan el carrito, hay que seguir pasando props.
    Acoplamiento: muchos componentes dependen directamente de App.jsx.
    ğŸ’¡ Esto prepara el terreno para la prÃ³xima etapa: usar Context API como soluciÃ³n a estos problemas. 

ğŸ“Œ ConclusiÃ³n
Esta versiÃ³n del carrito:

Es funcional, robusta y didÃ¡ctica.
Refuerza los fundamentos de React (estado, props, efectos).
Introduce buenas prÃ¡cticas de persistencia.
Sirve como base para entender por quÃ© necesitamos Context API en aplicaciones mÃ¡s grandes.
<<<<<<< HEAD




==========================================================================================
descripcion de las funciones 
==========================================================================================
1. ğŸ“¥ getInitialCart() â€“ Cargar carrito desde el almacenamiento

        const getInitialCart = () => {
            try {
                const savedCart = localStorage.getItem("cart");
                if (savedCart) {
                const parsed = JSON.parse(savedCart);
                return Array.isArray(parsed) ? parsed : [];
                }
            } catch (e) {
                console.error("Error al cargar el carrito:", e);
                localStorage.removeItem("cart");
            }
            return [];
        };

Â¿QuÃ© hace?
    Intenta recuperar el carrito guardado en localStorage bajo la clave "cart".
    Si existe y es un arreglo vÃ¡lido, lo devuelve.
    Si hay un error (por ejemplo, datos corruptos), lo elimina y devuelve un arreglo vacÃ­o.

Â¿Por quÃ© es importante?
    Permite que el carrito persista entre recargas del navegador.
    Incluye manejo de errores para evitar que la app se rompa si los datos estÃ¡n mal formateados.

-------------------------------------------------------------------------------------------------------
2. ğŸ§  Estado inicial del carrito

    const [carrito, setCarrito] = useState(getInitialCart);

    El estado carrito comienza con lo que devuelve getInitialCart().
    Es un arreglo de objetos, donde cada objeto representa un producto con una propiedad cantidad.
    
    Ejemplo de un Ã­tem en el carrito:
        { id: 1, title: "iPhone", price: 899, cantidad: 2 }

--------------------------------------------------------------------------------------------------------
3. ğŸ’¾ Persistencia automÃ¡tica con useEffect

            useEffect(() => {
                localStorage.setItem("cart", JSON.stringify(carrito));
            }, [carrito]);

    Â¿QuÃ© hace?
        Cada vez que el carrito cambia, lo guarda automÃ¡ticamente en localStorage.
        Usa JSON.stringify() porque localStorage solo almacena cadenas de texto.

    Â¿Por quÃ© es Ãºtil?
        El usuario no pierde sus productos si cierra la pestaÃ±a o recarga la pÃ¡gina.

----------------------------------------------------------------------------------------------------
4. â• agregarAlCarrito(producto)

            const agregarAlCarrito = (producto) => {
                setCarrito(prev => {
                    const existe = prev.find(item => item.id === producto.id);
                    if (existe) {
                    return prev.map(item =>
                        item.id === producto.id
                        ? { ...item, cantidad: item.cantidad + 1 }
                        : item
                    );
                    } else {
                    return [...prev, { ...producto, cantidad: 1 }];
                    }
                });
            };

    Â¿QuÃ© hace?
        Agrega un producto al carrito.
        Si ya existe â†’ incrementa su cantidad.
        Si no existe â†’ lo agrega como nuevo con cantidad: 1.

    Conceptos clave:
        Inmutabilidad: nunca se modifica el estado directamente.
        Spread operator (...): crea copias seguras de objetos y arreglos.
        prev en setCarrito(prev => ...): garantiza que siempre se use el valor mÃ¡s reciente del estado.

----------------------------------------------------------------------------------------------------
5. ğŸ—‘ï¸ eliminarDelCarrito(id)

            const eliminarDelCarrito = (id) => {
                setCarrito(prev => prev.filter(item => item.id !== id));
            };

    Â¿QuÃ© hace?
        Elimina un producto del carrito usando su id.
        Usa .filter() para crear un nuevo arreglo sin el producto eliminado.
    
    Ejemplo:
        Carrito antes:  
        [
            { id: 1, cantidad: 2 }, 
            { id: 3, cantidad: 1 }
        ]

    Llamada: eliminarDelCarrito(1)
        Carrito despuÃ©s:
        [
            { id: 3, cantidad: 1 }
        ]

------------------------------------------------------------------------------------------------------------
6. âœï¸ actualizarCantidad(id, nuevaCantidad)

            const actualizarCantidad = (id, nuevaCantidad) => {
                if (nuevaCantidad < 1) return;
                setCarrito(prev =>
                    prev.map(item =>
                    item.id === id
                        ? { ...item, cantidad: nuevaCantidad }
                        : item
                    )
                );
            };

    Â¿QuÃ© hace?
        Cambia la cantidad de un producto especÃ­fico.
        No permite cantidades menores a 1 (evita errores de UX).

    Â¿Por quÃ© no usar nuevaCantidad = 0 para eliminar?
        Por diseÃ±o: eliminar se hace con eliminarDelCarrito.
        Esto mantiene las responsabilidades separadas y el cÃ³digo mÃ¡s claro.
    
-----------------------------------------------------------------------------------------
7. ğŸ§¹ vaciarCarrito()

            const vaciarCarrito = () => {
                const confirmacion = window.confirm("Â¿EstÃ¡ seguro de que desea vaciar el carrito?");
                if (confirmacion) {
                    setCarrito([]);
                }
            };
    
    Â¿QuÃ© hace?
        Limpia todo el carrito tras confirmaciÃ³n del usuario.
        Usa window.confirm() para evitar eliminaciones accidentales.
    Buenas prÃ¡cticas:
        Siempre pide confirmaciÃ³n antes de borrar datos importantes.
        Solo vacÃ­a si el usuario acepta.

-------------------------------------------------------------------------------------------
8. ğŸ“¤ enviarPedido()

            const enviarPedido = () => {
                const confirmacion = window.confirm("Â¿Desea finalizar la compra?");
                if (!confirmacion) return;
                if (carrito.length === 0) {
                    alert("El carrito estÃ¡ vacÃ­o");
                    return;
                }

                fetch("https://dummyjson.com/carts/add", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        userId: 1,
                        products: carrito.map(item => ({
                            id: item.id,
                            quantity: item.cantidad,
                        })),
                    }),
                })
                .then(res => {
                    if (!res.ok) throw new Error(`Error ${res.status}`);
                    return res.json();
                })
                .then(data => {
                    alert("âœ… Â¡Gracias por su compra!\nID del carrito: " + data.id);
                    setCarrito([]); // Vaciar SOLO si fue exitoso
                })
                .catch(error => {
                    alert("âŒ Error al procesar la compra:\n" + error.message);
                });
            };
    
    QuÃ© hace?
        EnvÃ­a el carrito a una API real (dummyjson.com).
        Valida que el carrito no estÃ© vacÃ­o.
        Muestra mensajes de Ã©xito o error.
        VacÃ­a el carrito solo si la compra fue exitosa.

    Formato de datos enviado:
        {
            "userId": 1,
            "products": [
                { "id": 1, "quantity": 2 },
                { "id": 5, "quantity": 1 }
            ]
        }
=======
>>>>>>> e18fb7feafbed3873eaa39f811ce572ac86267be
