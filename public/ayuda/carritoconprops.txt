
Mejoras Clave en Busquedas

1. Manejo del TÃ©rmino de BÃºsqueda (Robustez)

  CÃ³digo Original	CÃ³digo Mejorado	Beneficio
    const txtBuscar = location.state;	        // original
    const txtBuscar = location.state?.trim()  // mejorado	
  
    const URI=API+txtBuscar;	                                            // original
    const URI = txtBuscar ? API + encodeURIComponent(txtBuscar) : null;	  // mejorado
  
  âœ… Seguridad de URL: Utiliza encodeURIComponent() para hacer que la URL sea vÃ¡lida, manejando espacios y caracteres especiales.

2. Rendimiento y Advertencias de React (Eficiencia)

  CÃ³digo Original	CÃ³digo Mejorado	Beneficio
    const getDatos = async () => {...}	
    const getDatos = useCallback(async () => {...}, [URI]);	
    âœ… Estabilidad de la FunciÃ³n: 
        El uso de useCallback "memoriza" la funciÃ³n getDatos. 
        Esto evita que la funciÃ³n se recree en cada renderizado, lo que a su vez elimina la advertencia de dependencia de useEffect y mejora el rendimiento.

    useEffect(() => { getDatos(); }, [txtBuscar]);	
    useEffect(() => { /* lÃ³gica de verificaciÃ³n */ }, [txtBuscar, getDatos]);	
    âœ… Uso Correcto de Dependencias: 
        Al usar useCallback, se sigue la regla de React de incluir a getDatos en el array de dependencias de useEffect sin causar bucles de renderizado.

3. Experiencia de Usuario y LÃ³gica (UX y Robustez)

  CÃ³digo Original	CÃ³digo Mejorado	Beneficio
    Sin validaciÃ³n para txtBuscar vacÃ­o.	
    Incluye if (!URI) { ... return; } en getDatos.	
    âœ… Control de Flujo: 
      Detiene la llamada a fetch si no hay tÃ©rmino de bÃºsqueda, evitando solicitudes innecesarias o con errores.

      El setLoading(false) solo estÃ¡ en el try y en el catch.	
      El setLoading(false) estÃ¡ en el bloque finally.	
    âœ… Manejo de Carga: 
        Garantiza que el estado de carga (loading) siempre se desactive, 
        incluso si hay un error desconocido o no manejado dentro del try/catch.

      













ğŸ›’ Etapa 3: Carrito de Compras â€“ VersiÃ³n 1 (GestiÃ³n con Props)
ğŸ¯ Objetivo
Implementar un carrito de compras funcional que permita a los usuarios:

Agregar productos desde la tienda o tarjetas.
Ver el contenido del carrito en un panel lateral (Offcanvas de Bootstrap).
Modificar cantidades, eliminar productos y vaciar el carrito.
Persistir el carrito entre recargas de la pÃ¡gina usando localStorage.
Esta versiÃ³n no usa Context API, sino que gestiona el estado del carrito en el componente raÃ­z (App.jsx) y lo pasa como prop a los componentes que lo necesitan.


Arquitectura del Estado
Componente                      Responsabilidad
----------------------------------------------------------------------------------------------------------
App.jsx                         - Contiene el estado del carrito (useState).
                                - Define funciones para gestionarlo (agregar,eliminar, etc.).
                                - Persiste el carrito en localStorage       
                                - Pasa el carrito y sus funciones como props.

Header.jsx                      - Muestra un botÃ³n con el nÃºmero de productos.
                                - Renderiza el CarritoOffcanvas
                                - Recibe el carrito y las funciones como props.

Cardprod.jsx                    - Muestra un botÃ³n â€œ+ Agregarâ€.
                                - Llama a agregarAlCarrito al hacer clic.
                                - Recibe la funciÃ³n como prop.

Tienda.jsx                      - Renderiza la lista de productos.
                                - Pasa agregarAlCarrito a cada Cardprod

CarritoOffcanvas.jsx            - Muestra los productos del carrito.    
                                - Permite modificar cantidades, eliminar y vaciar.
                                - Usa las funciones recibidas por props (Â¡no tiene estado propio!).



ğŸ’¾ Persistencia con localStorage
Para que el carrito no se pierda al recargar la pÃ¡gina, se utiliza localStorage:

âœ… InicializaciÃ³n segura del estado:

en la zona de importacion 
    const getInitialCart = () => {
    try {
        const saved = localStorage.getItem("cart");
        return saved ? JSON.parse(saved) : [];
    } catch (e) {
        console.error("Error al cargar el carrito");
        return [];
    }
    };

en la zona de la logica 
    const [carrito, setCarrito] = useState(getInitialCart);

    âœ… Guardado automÃ¡tico:

    useEffect(() => {
        localStorage.setItem("cart", JSON.stringify(carrito));
    }, [carrito]); // al cambiar el carrito actualiza el cart

    âœ¨ Ventaja: El carrito sobrevive a recargas, cierres del navegador y navegaciÃ³n. 



ğŸ“¦ Funcionalidades implementadas â€“ Etapa 3: Carrito 1 (con props)
âœ… Agregar producto: si ya existe en el carrito, incrementa su cantidad.
âœ… Eliminar producto: elimina un Ã­tem especÃ­fico del carrito.
âœ… Actualizar cantidad: botones + y â€“ para modificar unidades directamente en el Offcanvas.
âœ… Vaciar carrito: con confirmaciÃ³n previa para evitar acciones accidentales.
âœ… Enviar pedido: envÃ­a el carrito simulado a https://dummyjson.com/carts/add con confirmaciÃ³n de compra.
âœ… Mostrar totales:
    Total de productos Ãºnicos.
    Cantidad total de Ã­tems.
    Monto total a pagar (suma de precio Ã— cantidad).
âœ… Indicador visual en tarjetas: badge amarillo con la cantidad si el producto estÃ¡ en el carrito.
âœ… Contador en el botÃ³n del carrito: solo visible si hay productos (Carrito (3)).
âœ… Interfaz con Offcanvas de Bootstrap: panel lateral deslizable con resumen del carrito.
âœ… Persistencia con localStorage: el carrito se mantiene entre recargas y sesiones.



âš ï¸ Limitaciones de esta versiÃ³n (para reflexiÃ³n)
    Prop drilling: el carrito y sus funciones se pasan por muchos niveles de componentes.
    DifÃ­cil de escalar: si mÃ¡s componentes necesitan el carrito, hay que seguir pasando props.
    Acoplamiento: muchos componentes dependen directamente de App.jsx.
    ğŸ’¡ Esto prepara el terreno para la prÃ³xima etapa: usar Context API como soluciÃ³n a estos problemas. 

ğŸ“Œ ConclusiÃ³n
Esta versiÃ³n del carrito:

Es funcional, robusta y didÃ¡ctica.
Refuerza los fundamentos de React (estado, props, efectos).
Introduce buenas prÃ¡cticas de persistencia.
Sirve como base para entender por quÃ© necesitamos Context API en aplicaciones mÃ¡s grandes.
