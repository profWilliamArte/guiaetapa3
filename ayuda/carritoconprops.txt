
Mejoras Clave en Busquedas

1. Manejo del Término de Búsqueda (Robustez)

  Código Original	Código Mejorado	Beneficio
    const txtBuscar = location.state;	        // original
    const txtBuscar = location.state?.trim()  // mejorado	
  
    const URI=API+txtBuscar;	                                            // original
    const URI = txtBuscar ? API + encodeURIComponent(txtBuscar) : null;	  // mejorado
  
  ✅ Seguridad de URL: Utiliza encodeURIComponent() para hacer que la URL sea válida, manejando espacios y caracteres especiales.

2. Rendimiento y Advertencias de React (Eficiencia)

  Código Original	Código Mejorado	Beneficio
    const getDatos = async () => {...}	
    const getDatos = useCallback(async () => {...}, [URI]);	
    ✅ Estabilidad de la Función: 
        El uso de useCallback "memoriza" la función getDatos. 
        Esto evita que la función se recree en cada renderizado, lo que a su vez elimina la advertencia de dependencia de useEffect y mejora el rendimiento.

    useEffect(() => { getDatos(); }, [txtBuscar]);	
    useEffect(() => { /* lógica de verificación */ }, [txtBuscar, getDatos]);	
    ✅ Uso Correcto de Dependencias: 
        Al usar useCallback, se sigue la regla de React de incluir a getDatos en el array de dependencias de useEffect sin causar bucles de renderizado.

3. Experiencia de Usuario y Lógica (UX y Robustez)

  Código Original	Código Mejorado	Beneficio
    Sin validación para txtBuscar vacío.	
    Incluye if (!URI) { ... return; } en getDatos.	
    ✅ Control de Flujo: 
      Detiene la llamada a fetch si no hay término de búsqueda, evitando solicitudes innecesarias o con errores.

      El setLoading(false) solo está en el try y en el catch.	
      El setLoading(false) está en el bloque finally.	
    ✅ Manejo de Carga: 
        Garantiza que el estado de carga (loading) siempre se desactive, 
        incluso si hay un error desconocido o no manejado dentro del try/catch.

      








======================================================================================================================================================================
🛒 Etapa 3: Carrito de Compras – Versión 1 (Gestión con Props)
======================================================================================================================================================================

🎯 Objetivo
Implementar un carrito de compras funcional que permita a los usuarios:

Agregar productos desde la tienda o tarjetas.
Ver el contenido del carrito en un panel lateral (Offcanvas de Bootstrap).
Modificar cantidades, eliminar productos y vaciar el carrito.
Persistir el carrito entre recargas de la página usando localStorage.
Esta versión no usa Context API, sino que gestiona el estado del carrito en el componente raíz (App.jsx) y lo pasa como prop a los componentes que lo necesitan.


Arquitectura del Estado
Componente                      Responsabilidad
----------------------------------------------------------------------------------------------------------
App.jsx                         - Contiene el estado del carrito (useState).
                                - Define funciones para gestionarlo (agregar,eliminar, etc.).
                                - Persiste el carrito en localStorage       
                                - Pasa el carrito y sus funciones como props.

Header.jsx                      - Muestra un botón con el número de productos.
                                - Renderiza el CarritoOffcanvas
                                - Recibe el carrito y las funciones como props.

Cardprod.jsx                    - Muestra un botón “+ Agregar”.
                                - Llama a agregarAlCarrito al hacer clic.
                                - Recibe la función como prop.

Tienda.jsx                      - Renderiza la lista de productos.
                                - Pasa agregarAlCarrito a cada Cardprod

CarritoOffcanvas.jsx            - Muestra los productos del carrito.    
                                - Permite modificar cantidades, eliminar y vaciar.
                                - Usa las funciones recibidas por props (¡no tiene estado propio!).



💾 Persistencia con localStorage
Para que el carrito no se pierda al recargar la página, se utiliza localStorage:

✅ Inicialización segura del estado:

en la zona de importacion 
    const getInitialCart = () => {
    try {
        const saved = localStorage.getItem("cart");
        return saved ? JSON.parse(saved) : [];
    } catch (e) {
        console.error("Error al cargar el carrito");
        return [];
    }
    };

en la zona de la logica 
    const [carrito, setCarrito] = useState(getInitialCart);

    ✅ Guardado automático:

    useEffect(() => {
        localStorage.setItem("cart", JSON.stringify(carrito));
    }, [carrito]); // al cambiar el carrito actualiza el cart

    ✨ Ventaja: El carrito sobrevive a recargas, cierres del navegador y navegación. 



📦 Funcionalidades implementadas – Etapa 3: Carrito 1 (con props)
✅ Agregar producto: si ya existe en el carrito, incrementa su cantidad.
✅ Eliminar producto: elimina un ítem específico del carrito.
✅ Actualizar cantidad: botones + y – para modificar unidades directamente en el Offcanvas.
✅ Vaciar carrito: con confirmación previa para evitar acciones accidentales.
✅ Enviar pedido: envía el carrito simulado a https://dummyjson.com/carts/add con confirmación de compra.
✅ Mostrar totales:
    Total de productos únicos.
    Cantidad total de ítems.
    Monto total a pagar (suma de precio × cantidad).
✅ Indicador visual en tarjetas: badge amarillo con la cantidad si el producto está en el carrito.
✅ Contador en el botón del carrito: solo visible si hay productos (Carrito (3)).
✅ Interfaz con Offcanvas de Bootstrap: panel lateral deslizable con resumen del carrito.
✅ Persistencia con localStorage: el carrito se mantiene entre recargas y sesiones.



⚠️ Limitaciones de esta versión (para reflexión)
    Prop drilling: el carrito y sus funciones se pasan por muchos niveles de componentes.
    Difícil de escalar: si más componentes necesitan el carrito, hay que seguir pasando props.
    Acoplamiento: muchos componentes dependen directamente de App.jsx.
    💡 Esto prepara el terreno para la próxima etapa: usar Context API como solución a estos problemas. 

📌 Conclusión
Esta versión del carrito:

Es funcional, robusta y didáctica.
Refuerza los fundamentos de React (estado, props, efectos).
Introduce buenas prácticas de persistencia.
Sirve como base para entender por qué necesitamos Context API en aplicaciones más grandes.




==========================================================================================
descripcion de las funciones 
==========================================================================================
1. 📥 getInitialCart() – Cargar carrito desde el almacenamiento

        const getInitialCart = () => {
            try {
                const savedCart = localStorage.getItem("cart");
                if (savedCart) {
                const parsed = JSON.parse(savedCart);
                return Array.isArray(parsed) ? parsed : [];
                }
            } catch (e) {
                console.error("Error al cargar el carrito:", e);
                localStorage.removeItem("cart");
            }
            return [];
        };

¿Qué hace?
    Intenta recuperar el carrito guardado en localStorage bajo la clave "cart".
    Si existe y es un arreglo válido, lo devuelve.
    Si hay un error (por ejemplo, datos corruptos), lo elimina y devuelve un arreglo vacío.

¿Por qué es importante?
    Permite que el carrito persista entre recargas del navegador.
    Incluye manejo de errores para evitar que la app se rompa si los datos están mal formateados.

-------------------------------------------------------------------------------------------------------
2. 🧠 Estado inicial del carrito

    const [carrito, setCarrito] = useState(getInitialCart);

    El estado carrito comienza con lo que devuelve getInitialCart().
    Es un arreglo de objetos, donde cada objeto representa un producto con una propiedad cantidad.
    
    Ejemplo de un ítem en el carrito:
        { id: 1, title: "iPhone", price: 899, cantidad: 2 }

--------------------------------------------------------------------------------------------------------
3. 💾 Persistencia automática con useEffect

            useEffect(() => {
                localStorage.setItem("cart", JSON.stringify(carrito));
            }, [carrito]);

    ¿Qué hace?
        Cada vez que el carrito cambia, lo guarda automáticamente en localStorage.
        Usa JSON.stringify() porque localStorage solo almacena cadenas de texto.

    ¿Por qué es útil?
        El usuario no pierde sus productos si cierra la pestaña o recarga la página.

----------------------------------------------------------------------------------------------------
4. ➕ agregarAlCarrito(producto)

            const agregarAlCarrito = (producto) => {
                setCarrito(prev => {
                    const existe = prev.find(item => item.id === producto.id);
                    if (existe) {
                    return prev.map(item =>
                        item.id === producto.id
                        ? { ...item, cantidad: item.cantidad + 1 }
                        : item
                    );
                    } else {
                    return [...prev, { ...producto, cantidad: 1 }];
                    }
                });
            };

    ¿Qué hace?
        Agrega un producto al carrito.
        Si ya existe → incrementa su cantidad.
        Si no existe → lo agrega como nuevo con cantidad: 1.

    Conceptos clave:
        Inmutabilidad: nunca se modifica el estado directamente.
        Spread operator (...): crea copias seguras de objetos y arreglos.
        prev en setCarrito(prev => ...): garantiza que siempre se use el valor más reciente del estado.

----------------------------------------------------------------------------------------------------
5. 🗑️ eliminarDelCarrito(id)

            const eliminarDelCarrito = (id) => {
                setCarrito(prev => prev.filter(item => item.id !== id));
            };

    ¿Qué hace?
        Elimina un producto del carrito usando su id.
        Usa .filter() para crear un nuevo arreglo sin el producto eliminado.
    
    Ejemplo:
        Carrito antes:  
        [
            { id: 1, cantidad: 2 }, 
            { id: 3, cantidad: 1 }
        ]

    Llamada: eliminarDelCarrito(1)
        Carrito después:
        [
            { id: 3, cantidad: 1 }
        ]

------------------------------------------------------------------------------------------------------------
6. ✏️ actualizarCantidad(id, nuevaCantidad)

            const actualizarCantidad = (id, nuevaCantidad) => {
                if (nuevaCantidad < 1) return;
                setCarrito(prev =>
                    prev.map(item =>
                    item.id === id
                        ? { ...item, cantidad: nuevaCantidad }
                        : item
                    )
                );
            };

    ¿Qué hace?
        Cambia la cantidad de un producto específico.
        No permite cantidades menores a 1 (evita errores de UX).

    ¿Por qué no usar nuevaCantidad = 0 para eliminar?
        Por diseño: eliminar se hace con eliminarDelCarrito.
        Esto mantiene las responsabilidades separadas y el código más claro.
    
-----------------------------------------------------------------------------------------
7. 🧹 vaciarCarrito()

            const vaciarCarrito = () => {
                const confirmacion = window.confirm("¿Está seguro de que desea vaciar el carrito?");
                if (confirmacion) {
                    setCarrito([]);
                }
            };
    
    ¿Qué hace?
        Limpia todo el carrito tras confirmación del usuario.
        Usa window.confirm() para evitar eliminaciones accidentales.
    Buenas prácticas:
        Siempre pide confirmación antes de borrar datos importantes.
        Solo vacía si el usuario acepta.

-------------------------------------------------------------------------------------------
8. 📤 enviarPedido()

            const enviarPedido = () => {
                const confirmacion = window.confirm("¿Desea finalizar la compra?");
                if (!confirmacion) return;
                if (carrito.length === 0) {
                    alert("El carrito está vacío");
                    return;
                }

                fetch("https://dummyjson.com/carts/add", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        userId: 1,
                        products: carrito.map(item => ({
                            id: item.id,
                            quantity: item.cantidad,
                        })),
                    }),
                })
                .then(res => {
                    if (!res.ok) throw new Error(`Error ${res.status}`);
                    return res.json();
                })
                .then(data => {
                    alert("✅ ¡Gracias por su compra!\nID del carrito: " + data.id);
                    setCarrito([]); // Vaciar SOLO si fue exitoso
                })
                .catch(error => {
                    alert("❌ Error al procesar la compra:\n" + error.message);
                });
            };
    
    Qué hace?
        Envía el carrito a una API real (dummyjson.com).
        Valida que el carrito no esté vacío.
        Muestra mensajes de éxito o error.
        Vacía el carrito solo si la compra fue exitosa.

    Formato de datos enviado:
        {
            "userId": 1,
            "products": [
                { "id": 1, "quantity": 2 },
                { "id": 5, "quantity": 1 }
            ]
        }